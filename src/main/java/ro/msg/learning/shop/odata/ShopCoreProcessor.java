package ro.msg.learning.shop.odata;

import org.apache.olingo.odata2.api.ep.EntityProvider;
import org.apache.olingo.odata2.api.ep.EntityProviderReadProperties;
import org.apache.olingo.odata2.api.ep.EntityProviderWriteProperties;
import org.apache.olingo.odata2.api.ep.entry.ODataEntry;
import org.apache.olingo.odata2.api.exception.ODataException;
import org.apache.olingo.odata2.api.processor.ODataResponse;
import org.apache.olingo.odata2.api.processor.ODataSingleProcessor;
import org.apache.olingo.odata2.api.uri.info.GetEntityUriInfo;
import org.apache.olingo.odata2.api.uri.info.PostUriInfo;
import org.apache.olingo.odata2.core.ep.feed.ODataDeltaFeedImpl;
import org.springframework.beans.factory.annotation.Autowired;
import ro.msg.learning.shop.dto.InitialOrderDTO;
import ro.msg.learning.shop.dto.ProductDTO;
import ro.msg.learning.shop.exception.OrderHandlingException;
import ro.msg.learning.shop.model.Address;
import ro.msg.learning.shop.service.OrderService;

import java.io.InputStream;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.*;

public class ShopCoreProcessor extends ODataSingleProcessor {

    private OrderService orderService;

    @Autowired
    public ShopCoreProcessor(OrderService orderService) {
        this.orderService = orderService;
    }

    @Override
    public ODataResponse createEntity(PostUriInfo uriInfo, InputStream content, String requestContentType,
                                      String contentType) throws ODataException {

        EntityProviderReadProperties properties = EntityProviderReadProperties.init().mergeSemantic(false).build();

        ODataEntry entry = EntityProvider.readEntry(requestContentType, uriInfo.getStartEntitySet(), content,
                properties);
        //if something goes wrong in deserialization this is managed via the ExceptionMapper
        //no need for an application to do exception handling here an convert the exceptions in HTTP exceptions

        Map<String, Object> data = entry.getProperties();
        //now one can use the data to create the entry in the backend ...
        //retrieve the key value after creation, if the key is generated by the server
        InitialOrderDTO initialOrderDTO = new InitialOrderDTO();
        /*setup date*/
        Calendar calendarDate = (GregorianCalendar)data.get("Date");
        TimeZone tz = calendarDate.getTimeZone();
        ZoneId zid = tz == null ? ZoneId.systemDefault() : tz.toZoneId();
        initialOrderDTO.setDate(LocalDateTime.ofInstant(calendarDate.toInstant(), zid));
        /*setup address*/
        Map<String, String> addressMap = (Map<String, String>) data.get("Address");
        initialOrderDTO.setAddress(
                new Address(addressMap.get("Country"), addressMap.get("City"), addressMap.get("County"),
                        addressMap.get("Street")));
        /*setup products*/
        List<ProductDTO> productDTOs = new ArrayList<>();
        List<ODataEntry> productList = ((ODataDeltaFeedImpl)data.get("ProductDTOs")).getEntries();
        for (ODataEntry product : productList) {
            ProductDTO productDTO = new ProductDTO((Integer)product.getProperties().get("Id"), (Integer)product.getProperties().get("Quantity"));
            productDTOs.add(productDTO);
        }
        initialOrderDTO.setProducts(productDTOs);
        try {
            orderService.createOrder(initialOrderDTO);
        } catch (OrderHandlingException e) {
            e.printStackTrace();
        }

        //serialize the entry, Location header is set by OData Library
        return EntityProvider.writeEntry(contentType, uriInfo.getStartEntitySet(), entry.getProperties(),
                EntityProviderWriteProperties.serviceRoot(getContext().getPathInfo().getServiceRoot()).build());
    }

    @Override
    public ODataResponse readEntity(GetEntityUriInfo uriInfo, String contentType) throws ODataException {
        return super.readEntity(uriInfo, contentType);
    }
}
